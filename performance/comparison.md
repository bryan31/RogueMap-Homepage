# 对比分析

RogueMap 与其他键值存储方案的详细对比。

## RogueMap vs HashMap

### 性能对比

| 指标 | HashMap | RogueMap OffHeap | 差异 |
|-----|---------|------------------|------|
| 写入速度 | 611ms | 658ms | -7% |
| 读取速度 | 463ms | 251ms | **+84%** ✅ |
| 堆内存 | 304 MB | 40 MB | **-87%** ✅ |

### 优势分析

**RogueMap 优势**:
- ✅ 堆内存减少 **87%**
- ✅ 读取速度快 **84%**
- ✅ 降低 GC 压力
- ✅ 支持持久化

**HashMap 优势**:
- ✅ 写入速度略快 7%
- ✅ API 最简单
- ✅ 无需配置

### 适用场景

**使用 RogueMap 的场景**:
- 大数据量（100 万+ 条目）
- GC 压力敏感
- 需要持久化
- 高并发读取

**使用 HashMap 的场景**:
- 小数据量（< 10 万条目）
- 简单场景
- 无持久化需求
- 写入为主

## RogueMap vs MapDB

### 性能对比

| 指标 | RogueMap Mmap | MapDB | 优势 |
|-----|---------------|-------|------|
| 写入速度 | 632ms | 2,764ms | **4.4x** ✅ |
| 读取速度 | 202ms | 3,207ms | **15.9x** ✅ |
| 写吞吐量 | 1,582,278 ops/s | 361,794 ops/s | **4.4x** ✅ |
| 读吞吐量 | 4,950,495 ops/s | 311,817 ops/s | **15.9x** ✅ |
| 堆内存 | 40 MB | 0.08 MB | **-500x** ⚠️ |

### 核心差异

#### 性能差异

**写入性能**:
```
RogueMap: 1,582,278 ops/s ████████████████
MapDB:      361,794 ops/s ████
差距: 4.4 倍
```

**读取性能**:
```
RogueMap: 4,950,495 ops/s ████████████████████
MapDB:      311,817 ops/s ██
差距: 15.9 倍
```

#### 设计差异

| 方面 | RogueMap | MapDB |
|-----|----------|-------|
| 索引策略 | 64 段分段锁 | B+ 树 |
| 并发控制 | StampedLock 乐观锁 | 读写锁 |
| 内存分配 | Slab Allocator | 传统分配 |
| 序列化 | 零拷贝原始类型 | 通用序列化 |

### 适用场景

**使用 RogueMap 的场景**:
- ✅ 高性能要求
- ✅ 高并发读写
- ✅ 实时数据处理
- ✅ Web 应用缓存

**使用 MapDB 的场景**:
- ✅ 极低内存环境
- ✅ 嵌入式设备
- ✅ 复杂查询（B+ 树）
- ✅ 事务支持

## RogueMap vs Redis

### 对比分析

| 特性 | RogueMap | Redis |
|-----|----------|-------|
| 部署方式 | 嵌入式 | 独立服务 |
| 网络开销 | 无 | 有 |
| 数据结构 | Map | 多种 |
| 持久化 | 支持 | 支持 |
| 分布式 | 否 | 是 |
| 性能 | 极高 | 高 |

### 优势对比

**RogueMap 优势**:
- ✅ 零网络开销
- ✅ 嵌入式部署
- ✅ 更简单的运维
- ✅ 更高的吞吐量（本地）

**Redis 优势**:
- ✅ 丰富的数据结构
- ✅ 分布式支持
- ✅ 发布/订阅
- ✅ Lua 脚本

### 性能估算

假设单次操作耗时：

| 操作 | RogueMap | Redis (本地) | Redis (网络) |
|-----|----------|--------------|--------------|
| 读取 | 0.2 μs | 10 μs | 100 μs |
| 写入 | 0.5 μs | 15 μs | 150 μs |

**结论**: RogueMap 本地性能远超 Redis，但 Redis 提供更多功能。

### 适用场景

**使用 RogueMap 的场景**:
- ✅ 单机应用
- ✅ 嵌入式缓存
- ✅ 极致性能要求
- ✅ 简单键值存储

**使用 Redis 的场景**:
- ✅ 分布式系统
- ✅ 需要多种数据结构
- ✅ 多应用共享缓存
- ✅ 发布/订阅

## RogueMap vs Chronicle Map

### 对比分析

| 特性 | RogueMap | Chronicle Map |
|-----|----------|---------------|
| 性能 | 极高 | 极高 |
| 易用性 | 简单 | 复杂 |
| 持久化 | 支持 | 支持 |
| 依赖 | 零依赖 | 多个依赖 |
| 并发 | 分段锁 | 分段锁 |

### 优势对比

**RogueMap 优势**:
- ✅ 更简单的 API
- ✅ 零依赖
- ✅ 更灵活的模式
- ✅ 类型安全

**Chronicle Map 优势**:
- ✅ 更成熟稳定
- ✅ 更多企业应用
- ✅ 社区更大

### 适用场景

**使用 RogueMap 的场景**:
- ✅ 简单易用
- ✅ 快速上手
- ✅ 零依赖要求

**使用 Chronicle Map 的场景**:
- ✅ 需要成熟方案
- ✅ 企业级应用
- ✅ 长期维护

## 多模式性能对比

### RogueMap 内部对比

| 模式 | 写入(ms) | 读取(ms) | 堆内存(MB) | 持久化 |
|-----|----------|----------|------------|--------|
| HashMap | 611 | 463 | 304.04 | ❌ |
| OffHeap | 658 | 251 | 40.46 | ❌ |
| Mmap Temp | 629 | 212 | 40.13 | ❌ |
| **Mmap Persist** | **547** | **195** | **40.01** | ✅ |

**推荐**:
- 性能优先 → Mmap 持久化
- 内存敏感 → OffHeap
- 临时处理 → Mmap 临时
- 简单场景 → HashMap

## 总结

### 性能排名

**读取性能**:
1. RogueMap Mmap 持久化 (195ms) ⭐⭐⭐⭐⭐
2. RogueMap Mmap 临时 (212ms) ⭐⭐⭐⭐
3. RogueMap OffHeap (251ms) ⭐⭐⭐⭐
4. HashMap (463ms) ⭐⭐⭐
5. MapDB (3,207ms) ⭐

**写入性能**:
1. RogueMap Mmap 持久化 (547ms) ⭐⭐⭐⭐⭐
2. HashMap (611ms) ⭐⭐⭐⭐
3. RogueMap Mmap 临时 (629ms) ⭐⭐⭐⭐
4. RogueMap OffHeap (658ms) ⭐⭐⭐⭐
5. MapDB (2,764ms) ⭐

**内存效率**:
1. MapDB (0.08 MB) ⭐⭐⭐⭐⭐
2. RogueMap OffHeap/Mmap (40 MB) ⭐⭐⭐⭐
3. HashMap (304 MB) ⭐⭐

### 选择建议

| 需求 | 推荐方案 |
|-----|---------|
| 极致性能 | RogueMap Mmap 持久化 |
| 高并发 | RogueMap SegmentedIndex |
| 低内存 | MapDB 或 RogueMap OffHeap |
| 分布式 | Redis |
| 简单场景 | HashMap |
| 企业级 | Chronicle Map |

## 下一步

- [性能测试](./benchmark.md) - 详细性能数据
- [性能优化](./optimization.md) - 优化技巧
- [最佳实践](../guide/best-practices.md) - 使用建议

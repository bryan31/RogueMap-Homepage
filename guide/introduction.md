# 介绍

## 什么是 RogueMap？

**RogueMap** 是一个高性能的嵌入式键值存储引擎，专为 Java 应用设计。它将数据存储在 JVM 堆外内存或内存映射文件中，大幅降低 GC 压力的同时提供更高的吞吐量。

## 核心特性

### 🚀 高效写入

- **写入速度** 比 HashMap 快 **1.45 倍**（只写索引，不写数据）
- **百万级读取吞吐** 达到 155 万 ops/s，满足绝大多数业务场景
- 零拷贝序列化，原始类型直接内存布局
- 基于 Unsafe API 的底层优化

### 💾 灵活存储模式

RogueMap 支持三种存储模式：

1. **OffHeap 模式** - 堆外内存存储，降低 GC 压力
2. **Mmap 持久化模式** - 内存映射文件，支持数据持久化
3. **Mmap 临时文件模式** - 自动清理的临时文件存储

### 🔒 高并发支持

- 64 段分段锁设计，减少锁竞争
- StampedLock 乐观锁优化
- 线程安全，支持高并发读写

### 📊 低内存占用

- 堆外内存模式减少 **84.7%** 堆内存使用
- Slab Allocator 减少内存碎片
- 智能内存分配策略

## 设计目标

RogueMap 专注于解决"快、存储突破、并发安全"这个不可能三角中的后两项：

- ✅ **存储突破** - 堆外内存和磁盘 mmap 映射，突破 JVM 堆内存限制
- ✅ **并发安全** - 64 段分段锁，线程安全可靠
- ✅ **高效写入** - 只写索引不写数据，写入性能优秀
- ✅ **更低的内存占用** - 减少 84.7% 堆内存，大幅降低 GC 压力
- ✅ **更简单的 API** - 类型安全，易于使用
- ✅ **零依赖** - 核心库无第三方依赖
- ✅ **灵活的存储模式** - 适应不同场景

## 适用场景

RogueMap 特别适合以下场景：

- **高性能键值缓存** - 替代 Redis、Memcached 等外部缓存
- **大数据量临时处理** - 避免 OOM，降低 GC 压力
- **实时数据分析** - 高吞吐量读写
- **嵌入式键值存储** - 无需外部依赖
- **持久化配置管理** - 支持数据持久化
- **会话状态存储** - 高并发场景下的状态管理

## 与其他方案对比

### vs HashMap

- ✅ 堆外内存存储，减少 84.7% 堆内存占用
- ✅ 降低 GC 压力，提升应用稳定性
- ✅ 支持持久化，数据不丢失（HashMap 做不到）
- ✅ 写入速度快 **1.45 倍**（只写索引，不写数据）
- ⚠️ 读取速度约为 HashMap 的 1/4（因涉及序列化，但 155 万 ops/s 仍能满足绝大多数场景）

### vs FastUtil

- ✅ 堆外内存存储，减少 82.7% 堆内存占用（275.69 MB → 47.63 MB）
- ✅ 支持持久化，数据不丢失
- ⚠️ 读写性能低于 FastUtil（FastUtil 是纯内存优化方案）
- ✅ 适合内存敏感型应用

### vs Redis/Memcached

- ✅ 嵌入式，无需外部服务
- ✅ 零网络开销
- ✅ 更简单的部署和运维
- ✅ 本地性能比 Redis 高 1-2 个数量级
- ⚠️ 仅限单机使用，不支持分布式

## 系统要求

- **Java 版本**: Java 8 或更高版本
- **Maven 版本**: Maven 3.6+ (如果从源码构建)
- **操作系统**: 支持 Linux、macOS、Windows

## 下一步

- [快速开始](./getting-started.md) - 5 分钟上手 RogueMap
- [为什么选择 RogueMap](./why-roguemap.md) - 深入了解设计理念
- [存储模式](./storage-modes.md) - 了解三种存储模式的区别
